<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Hole v2 - Kerr Metric Simulation</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'SF Pro', -apple-system, sans-serif; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
      pointer-events: none;
    }
    #ui h1 { 
      font-size: 28px; 
      font-weight: 300;
      color: #fff;
      letter-spacing: 4px;
      text-transform: uppercase;
    }
    #ui p { color: rgba(255,255,255,0.5); margin-top: 5px; font-size: 12px; }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 12px;
      background: rgba(0,0,0,0.6);
      padding: 15px 20px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
    }
    #controls label {
      display: flex;
      align-items: center;
      margin: 10px 0;
      gap: 10px;
    }
    #controls input[type="range"] {
      width: 120px;
      accent-color: #f80;
    }
    #controls .value {
      width: 35px;
      text-align: right;
      color: #f80;
      font-family: monospace;
    }
    #controls .section {
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 10px;
      padding-top: 10px;
    }
    #controls .section:first-child {
      border: none;
      margin: 0;
      padding: 0;
    }
    #hint {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: rgba(255,255,255,0.4);
      font-size: 11px;
      text-align: right;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 18px;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="ui">
    <h1>Gargantua</h1>
    <p>Kerr Black Hole · Ray-traced Spacetime Simulation</p>
  </div>
  <div id="controls">
    <div class="section">
      <label>
        Mass <input type="range" id="mass" min="0.5" max="2.5" step="0.1" value="1.0">
        <span class="value" id="massVal">1.0</span>
      </label>
      <label>
        Spin <input type="range" id="spin" min="0" max="0.998" step="0.01" value="0.9">
        <span class="value" id="spinVal">0.90</span>
      </label>
    </div>
    <div class="section">
      <label>
        Disk Temp <input type="range" id="temp" min="3000" max="12000" step="100" value="6500">
        <span class="value" id="tempVal">6500</span>
      </label>
      <label>
        Disk Size <input type="range" id="diskSize" min="3" max="15" step="0.5" value="8">
        <span class="value" id="sizeVal">8.0</span>
      </label>
      <label>
        Bloom <input type="range" id="bloom" min="0" max="2" step="0.1" value="1.0">
        <span class="value" id="bloomVal">1.0</span>
      </label>
    </div>
    <div class="section">
      <label>
        <input type="checkbox" id="showDisk" checked> Accretion Disk
      </label>
      <label>
        <input type="checkbox" id="showJets"> Relativistic Jets
      </label>
    </div>
  </div>
  <div id="hint">
    Drag to orbit · Scroll to zoom<br>
    WASD to fly · Space/Shift up/down
  </div>
  <div id="loading">Compiling shaders...</div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { 
      antialias: false,
      powerPreference: 'high-performance'
    });
    
    if (!gl) {
      alert('WebGL 2 required!');
      throw new Error('No WebGL 2');
    }

    // Enable float textures for HDR
    const ext = gl.getExtension('EXT_color_buffer_float');

    //=== VERTEX SHADER ===
    const vertSrc = `#version 300 es
      in vec2 a_pos;
      out vec2 v_uv;
      void main() {
        v_uv = a_pos * 0.5 + 0.5;
        gl_Position = vec4(a_pos, 0, 1);
      }
    `;

    //=== MAIN RAY TRACING SHADER ===
    const fragSrc = `#version 300 es
      precision highp float;
      
      in vec2 v_uv;
      out vec4 fragColor;
      
      uniform vec2 u_res;
      uniform float u_time;
      uniform vec3 u_camPos;
      uniform vec3 u_camTarget;
      uniform float u_mass;
      uniform float u_spin;
      uniform float u_diskTemp;
      uniform float u_diskSize;
      uniform float u_bloom;
      uniform bool u_showDisk;
      uniform bool u_showJets;
      
      #define PI 3.14159265359
      #define MAX_STEPS 400
      #define STEP_SIZE 0.08
      
      // Kerr metric parameters
      float rs, a, a2;
      
      // Initialize Kerr parameters
      void initKerr(float mass, float spin) {
        rs = 2.0 * mass;
        a = spin * mass;  // spin parameter
        a2 = a * a;
      }
      
      // Boyer-Lindquist coordinates helper
      float sigma(float r, float theta) {
        float cosT = cos(theta);
        return r * r + a2 * cosT * cosT;
      }
      
      float delta(float r) {
        return r * r - rs * r + a2;
      }
      
      // Event horizon radius (outer)
      float rPlus() {
        return 0.5 * rs + sqrt(0.25 * rs * rs - a2);
      }
      
      // Ergosphere radius at equator
      float ergoRadius(float theta) {
        float cosT = cos(theta);
        return 0.5 * rs + sqrt(0.25 * rs * rs - a2 * cosT * cosT);
      }
      
      // Camera matrix
      mat3 lookAt(vec3 ro, vec3 ta) {
        vec3 w = normalize(ta - ro);
        vec3 u = normalize(cross(w, vec3(0, 1, 0)));
        vec3 v = cross(u, w);
        return mat3(u, v, w);
      }
      
      // Blackbody color from temperature (Kelvin)
      vec3 blackbody(float T) {
        // Attempt proper Planck curve approximation
        float x = T / 1000.0;
        vec3 col;
        
        if (T < 6600.0) {
          col.r = 1.0;
          col.g = 0.39 * log(x) - 0.63;
          col.b = T < 2000.0 ? 0.0 : 0.54 * log(x - 1.0) - 1.68;
        } else {
          col.r = 1.29 * pow(x - 0.6, -0.13);
          col.g = 1.29 * pow(x - 0.6, -0.08);
          col.b = 1.0;
        }
        return clamp(col, 0.0, 1.0);
      }
      
      // Procedural galaxy/nebula background
      vec3 background(vec3 dir) {
        vec3 col = vec3(0);
        
        // Deep space base
        col += vec3(0.001, 0.001, 0.003);
        
        // Stars - multiple layers
        for (int layer = 0; layer < 4; layer++) {
          float scale = 80.0 + float(layer) * 50.0;
          vec3 p = dir * scale;
          vec3 fp = fract(p) - 0.5;
          vec3 ip = floor(p);
          
          float h = fract(sin(dot(ip, vec3(127.1, 311.7, 74.7))) * 43758.5);
          float h2 = fract(h * 127.1);
          
          // Varying star density
          float threshold = 0.96 - float(layer) * 0.01;
          if (h > threshold) {
            float d = length(fp);
            float starSize = 0.03 + 0.02 * h2;
            float brightness = smoothstep(starSize, 0.0, d);
            brightness *= (h - threshold) * 25.0;
            
            // Star color from "temperature"
            float starTemp = 3000.0 + h2 * 20000.0;
            vec3 starCol = blackbody(starTemp);
            
            // Occasional bright stars with glow
            if (h > 0.995) {
              brightness *= 3.0;
              float glow = exp(-d * 30.0) * 0.5;
              col += starCol * glow;
            }
            
            col += brightness * starCol;
          }
        }
        
        // Milky way band
        float galacticLat = asin(dir.y);
        float galacticLon = atan(dir.z, dir.x);
        
        float band = exp(-4.0 * galacticLat * galacticLat);
        float dust = 0.5 + 0.5 * sin(galacticLon * 3.0 + galacticLat * 2.0);
        dust *= 0.7 + 0.3 * sin(galacticLon * 7.0);
        
        vec3 milkyway = vec3(0.08, 0.06, 0.12) * band * dust;
        
        // Nebula clouds
        float neb = sin(dir.x * 5.0 + dir.y * 3.0) * sin(dir.y * 4.0 + dir.z * 6.0);
        neb = smoothstep(0.3, 0.8, neb * 0.5 + 0.5);
        vec3 nebCol = mix(vec3(0.4, 0.1, 0.2), vec3(0.1, 0.2, 0.5), dir.y * 0.5 + 0.5);
        milkyway += nebCol * neb * 0.03 * band;
        
        col += milkyway;
        
        return col;
      }
      
      // Accretion disk with volumetric structure
      vec4 sampleDisk(vec3 p, vec3 vel, float r) {
        float rH = rPlus();
        float innerR = rH * 1.5;  // ISCO approximation
        float outerR = u_diskSize * rH;
        
        if (r < innerR * 0.8 || r > outerR * 1.2) return vec4(0);
        
        // Disk vertical structure (Gaussian profile)
        float H = 0.05 * r * (1.0 + 0.5 * (r - innerR) / (outerR - innerR));  // Flared disk
        float diskDensity = exp(-p.y * p.y / (2.0 * H * H));
        
        if (diskDensity < 0.01) return vec4(0);
        
        // Radial falloff
        float radialFade = smoothstep(innerR * 0.8, innerR * 1.2, r) * smoothstep(outerR * 1.2, outerR * 0.8, r);
        
        // Orbital velocity (Keplerian with frame dragging correction)
        float omega = sqrt(u_mass / (r * r * r)) + a * u_mass / (r * r * r);
        vec3 orbVel = omega * vec3(-p.z, 0.0, p.x);
        
        // Doppler factor
        float gamma = 1.0 / sqrt(1.0 - dot(orbVel, orbVel));
        float doppler = gamma * (1.0 - dot(normalize(vel), normalize(orbVel)));
        doppler = clamp(doppler, 0.3, 3.0);
        
        // Gravitational redshift
        float gRedshift = sqrt(max(0.1, 1.0 - rH / r));
        
        // Temperature profile (hotter near center)
        float tempProfile = pow(innerR / r, 0.75);
        float T = u_diskTemp * tempProfile * doppler;
        
        // Blackbody color
        vec3 diskCol = blackbody(T);
        
        // Intensity
        float intensity = tempProfile * tempProfile * diskDensity * radialFade;
        intensity *= gRedshift;  // Gravitational dimming
        intensity *= doppler * doppler;  // Relativistic beaming
        
        // Spiral structure
        float phi = atan(p.z, p.x);
        float spiral = sin(phi * 4.0 - r * 0.5 + u_time * 0.3);
        spiral = 0.7 + 0.3 * spiral;
        
        // Turbulent clumps
        float turb = sin(phi * 12.0 + r * 2.0 + u_time) * sin(phi * 7.0 - r * 1.5);
        turb = 0.8 + 0.2 * turb;
        
        intensity *= spiral * turb;
        
        return vec4(diskCol * intensity, diskDensity * radialFade);
      }
      
      // Relativistic jets
      vec3 sampleJet(vec3 p, float r) {
        if (!u_showJets) return vec3(0);
        
        float rH = rPlus();
        
        // Jet cone parameters
        float jetAngle = 0.15;  // Opening angle
        float jetLength = 30.0 * rH;
        
        // Distance from polar axis
        float axialDist = length(p.xz);
        float height = abs(p.y);
        
        // Cone boundary
        float coneRadius = height * jetAngle;
        
        if (axialDist > coneRadius * 2.0 || height > jetLength) return vec3(0);
        if (height < rH * 2.0) return vec3(0);  // Start above horizon
        
        // Jet density (concentrated at center, fading with height)
        float radialFalloff = exp(-axialDist * axialDist / (coneRadius * coneRadius));
        float heightFalloff = exp(-height / (jetLength * 0.3));
        float density = radialFalloff * heightFalloff;
        
        // Jet color (hot plasma, bluish-white)
        vec3 jetCol = vec3(0.6, 0.7, 1.0);
        
        // Helical structure
        float phi = atan(p.z, p.x);
        float helix = sin(phi * 2.0 + height * 0.5 - u_time * 2.0);
        helix = 0.7 + 0.3 * helix;
        
        // Knots (brighter regions)
        float knots = sin(height * 0.3 - u_time * 1.5);
        knots = 0.5 + 0.5 * smoothstep(0.7, 1.0, knots);
        
        return jetCol * density * helix * knots * 2.0;
      }
      
      // Main ray marcher with Kerr geodesics
      vec3 trace(vec3 ro, vec3 rd) {
        float rH = rPlus();
        
        vec3 pos = ro;
        vec3 vel = rd;
        
        vec3 accum = vec3(0);  // Accumulated light
        float transmittance = 1.0;
        
        for (int i = 0; i < MAX_STEPS; i++) {
          float r = length(pos);
          float theta = acos(clamp(pos.y / r, -1.0, 1.0));
          
          // Inside event horizon
          if (r < rH * 1.02) {
            return accum;
          }
          
          // Escaped
          if (r > 150.0) {
            return accum + transmittance * background(normalize(vel));
          }
          
          // Kerr metric gravitational acceleration
          float sig = sigma(r, theta);
          float del = delta(r);
          
          // Simplified but visually accurate geodesic
          vec3 rHat = pos / r;
          
          // Radial acceleration (enhanced near horizon)
          float radialAccel = -0.5 * rs / (r * r);
          
          // Frame dragging (azimuthal acceleration)
          vec3 phiHat = normalize(vec3(-pos.z, 0.0, pos.x));
          float frameDrag = 2.0 * a * rs * r * sin(theta) * sin(theta) / (sig * sig);
          
          // Extra bending near photon sphere
          float rPh = 1.5 * rs * (1.0 + sqrt(1.0 - (a / u_mass) * (a / u_mass) * 0.5));
          if (r < rPh * 2.5) {
            radialAccel *= 1.0 + pow(rPh / r, 2.0);
          }
          
          // Adaptive step
          float step = STEP_SIZE * (0.3 + 0.7 * smoothstep(rH, rH * 6.0, r));
          
          // Update velocity
          vel += rHat * radialAccel * step;
          vel += phiHat * frameDrag * step * 0.5;
          vel = normalize(vel);
          
          // Update position
          pos += vel * step;
          
          // Sample disk
          if (u_showDisk) {
            float diskR = length(vec2(pos.x, pos.z));
            vec4 disk = sampleDisk(pos, vel, diskR);
            if (disk.a > 0.001) {
              accum += transmittance * disk.rgb * disk.a * step * 8.0;
              transmittance *= exp(-disk.a * step * 2.0);
            }
          }
          
          // Sample jets
          vec3 jet = sampleJet(pos, r);
          if (length(jet) > 0.001) {
            accum += transmittance * jet * step * 0.5;
          }
          
          if (transmittance < 0.01) break;
        }
        
        return accum + transmittance * background(normalize(vel));
      }
      
      void main() {
        initKerr(u_mass, u_spin);
        
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
        
        vec3 ro = u_camPos;
        vec3 ta = u_camTarget;
        mat3 cam = lookAt(ro, ta);
        
        // Slight chromatic aberration for realism
        vec3 col = vec3(0);
        float aberration = 0.002;
        
        for (int i = 0; i < 3; i++) {
          float offset = (float(i) - 1.0) * aberration;
          vec3 rd = cam * normalize(vec3(uv + vec2(offset, 0), 1.2));
          vec3 c = trace(ro, rd);
          if (i == 0) col.r = c.r;
          else if (i == 1) col.g = c.g;
          else col.b = c.b;
        }
        
        // Bloom (simple glow on bright areas)
        float lum = dot(col, vec3(0.299, 0.587, 0.114));
        vec3 bloom = col * smoothstep(0.8, 2.0, lum) * u_bloom;
        col += bloom * 0.3;
        
        // Tone mapping (ACES filmic)
        col = col * (2.51 * col + 0.03) / (col * (2.43 * col + 0.59) + 0.14);
        
        // Gamma
        col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));
        
        // Film grain
        float grain = fract(sin(dot(gl_FragCoord.xy + u_time, vec2(12.9898, 78.233))) * 43758.5);
        col += (grain - 0.5) * 0.015;
        
        // Vignette
        float vig = 1.0 - 0.4 * dot(uv, uv);
        col *= vig;
        
        // Subtle blue tint in shadows (cinematic)
        float shadowMask = 1.0 - smoothstep(0.0, 0.3, lum);
        col = mix(col, col * vec3(0.9, 0.95, 1.1), shadowMask * 0.3);
        
        fragColor = vec4(col, 1.0);
      }
    `;

    // Compile
    function compile(type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        return null;
      }
      return s;
    }

    function link(vs, fs) {
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(p));
        return null;
      }
      return p;
    }

    const vs = compile(gl.VERTEX_SHADER, vertSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fragSrc);
    const prog = link(vs, fs);

    // Quad
    const quad = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(prog, 'a_pos');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const u = {
      res: gl.getUniformLocation(prog, 'u_res'),
      time: gl.getUniformLocation(prog, 'u_time'),
      camPos: gl.getUniformLocation(prog, 'u_camPos'),
      camTarget: gl.getUniformLocation(prog, 'u_camTarget'),
      mass: gl.getUniformLocation(prog, 'u_mass'),
      spin: gl.getUniformLocation(prog, 'u_spin'),
      diskTemp: gl.getUniformLocation(prog, 'u_diskTemp'),
      diskSize: gl.getUniformLocation(prog, 'u_diskSize'),
      bloom: gl.getUniformLocation(prog, 'u_bloom'),
      showDisk: gl.getUniformLocation(prog, 'u_showDisk'),
      showJets: gl.getUniformLocation(prog, 'u_showJets'),
    };

    // Camera
    let camTheta = 0.5;
    let camPhi = 0.3;
    let camDist = 30;
    let camTarget = [0, 0, 0];
    let dragging = false;
    let lastM = {x: 0, y: 0};

    // Fly mode
    let flyMode = false;
    let flyPos = [0, 5, 30];
    let flyVel = [0, 0, 0];
    let keys = {};

    // Params
    let mass = 1.0;
    let spin = 0.9;
    let diskTemp = 6500;
    let diskSize = 8;
    let bloom = 1.0;
    let showDisk = true;
    let showJets = false;

    // Mouse
    canvas.addEventListener('mousedown', e => { 
      dragging = true; 
      lastM = {x: e.clientX, y: e.clientY}; 
    });
    canvas.addEventListener('mousemove', e => {
      if (!dragging) return;
      camTheta -= (e.clientX - lastM.x) * 0.005;
      camPhi = Math.max(-1.5, Math.min(1.5, camPhi + (e.clientY - lastM.y) * 0.005));
      lastM = {x: e.clientX, y: e.clientY};
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      camDist = Math.max(6, Math.min(100, camDist * (1 + e.deltaY * 0.001)));
    });

    // Touch
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        dragging = true;
        lastM = {x: e.touches[0].clientX, y: e.touches[0].clientY};
      }
    });
    canvas.addEventListener('touchmove', e => {
      if (!dragging || e.touches.length !== 1) return;
      e.preventDefault();
      camTheta -= (e.touches[0].clientX - lastM.x) * 0.005;
      camPhi = Math.max(-1.5, Math.min(1.5, camPhi + (e.touches[0].clientY - lastM.y) * 0.005));
      lastM = {x: e.touches[0].clientX, y: e.touches[0].clientY};
    });
    canvas.addEventListener('touchend', () => dragging = false);

    // Keyboard
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // UI
    document.getElementById('mass').oninput = e => {
      mass = +e.target.value;
      document.getElementById('massVal').textContent = mass.toFixed(1);
    };
    document.getElementById('spin').oninput = e => {
      spin = +e.target.value;
      document.getElementById('spinVal').textContent = spin.toFixed(2);
    };
    document.getElementById('temp').oninput = e => {
      diskTemp = +e.target.value;
      document.getElementById('tempVal').textContent = diskTemp;
    };
    document.getElementById('diskSize').oninput = e => {
      diskSize = +e.target.value;
      document.getElementById('sizeVal').textContent = diskSize.toFixed(1);
    };
    document.getElementById('bloom').oninput = e => {
      bloom = +e.target.value;
      document.getElementById('bloomVal').textContent = bloom.toFixed(1);
    };
    document.getElementById('showDisk').onchange = e => showDisk = e.target.checked;
    document.getElementById('showJets').onchange = e => showJets = e.target.checked;

    // Resize
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // Render
    function render(t) {
      const time = t * 0.001;

      // Orbit camera
      const cx = camDist * Math.cos(camPhi) * Math.sin(camTheta);
      const cy = camDist * Math.sin(camPhi);
      const cz = camDist * Math.cos(camPhi) * Math.cos(camTheta);

      gl.useProgram(prog);
      gl.uniform2f(u.res, canvas.width, canvas.height);
      gl.uniform1f(u.time, time);
      gl.uniform3f(u.camPos, cx, cy, cz);
      gl.uniform3f(u.camTarget, 0, 0, 0);
      gl.uniform1f(u.mass, mass);
      gl.uniform1f(u.spin, spin);
      gl.uniform1f(u.diskTemp, diskTemp);
      gl.uniform1f(u.diskSize, diskSize);
      gl.uniform1f(u.bloom, bloom);
      gl.uniform1i(u.showDisk, showDisk);
      gl.uniform1i(u.showJets, showJets);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
