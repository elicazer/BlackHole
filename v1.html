<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Hole - Schwarzschild Ray Tracer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #000; 
      overflow: hidden; 
      font-family: 'Segoe UI', sans-serif;
    }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      opacity: 0.8;
      pointer-events: none;
    }
    #info h1 { font-size: 24px; margin-bottom: 10px; }
    #info p { margin: 4px 0; color: #aaa; }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 13px;
    }
    #controls label {
      display: block;
      margin: 8px 0;
    }
    #controls input[type="range"] {
      width: 150px;
      vertical-align: middle;
    }
    #controls span {
      display: inline-block;
      width: 50px;
      text-align: right;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <h1>üï≥Ô∏è Black Hole</h1>
    <p>Schwarzschild spacetime ray tracer</p>
    <p>Drag to orbit ‚Ä¢ Scroll to zoom</p>
  </div>
  <div id="controls">
    <label>
      Black Hole Mass: <input type="range" id="mass" min="0.5" max="3" step="0.1" value="1.5">
      <span id="massVal">1.5</span>
    </label>
    <label>
      Disk Brightness: <input type="range" id="diskBright" min="0" max="2" step="0.1" value="1">
      <span id="diskVal">1.0</span>
    </label>
    <label>
      Disk Inner Radius: <input type="range" id="diskInner" min="2" max="6" step="0.5" value="3">
      <span id="innerVal">3.0</span>
    </label>
    <label>
      <input type="checkbox" id="showDisk" checked> Show Accretion Disk
    </label>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    
    if (!gl) {
      alert('WebGL not supported!');
      throw new Error('No WebGL');
    }

    // Vertex shader - simple fullscreen quad
    const vertexShaderSource = `#version 300 es
      in vec2 a_position;
      out vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Fragment shader - the black hole ray tracer
    const fragmentShaderSource = `#version 300 es
      precision highp float;
      
      in vec2 v_uv;
      out vec4 fragColor;
      
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_cameraPos;
      uniform vec3 u_cameraTarget;
      uniform float u_mass;
      uniform float u_diskBrightness;
      uniform float u_diskInner;
      uniform bool u_showDisk;
      
      #define PI 3.14159265359
      #define MAX_STEPS 256
      #define STEP_SIZE 0.15
      
      // Schwarzschild radius (r_s = 2GM/c¬≤ = 2M in geometric units)
      float schwarzschildRadius(float mass) {
        return 2.0 * mass;
      }
      
      // Photon sphere radius (r_ph = 3GM/c¬≤ = 1.5 * r_s)
      float photonSphereRadius(float mass) {
        return 1.5 * schwarzschildRadius(mass);
      }
      
      // Create camera ray
      mat3 setCamera(vec3 ro, vec3 ta) {
        vec3 w = normalize(ta - ro);
        vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));
        vec3 v = cross(u, w);
        return mat3(u, v, w);
      }
      
      // Star field background
      vec3 starField(vec3 dir) {
        // Procedural stars
        vec3 col = vec3(0.0);
        
        // Multiple layers of stars
        for (int i = 0; i < 3; i++) {
          float scale = 50.0 + float(i) * 30.0;
          vec3 p = dir * scale;
          vec3 f = fract(p) - 0.5;
          vec3 id = floor(p);
          
          // Random per cell
          float h = fract(sin(dot(id, vec3(127.1, 311.7, 74.7))) * 43758.5453);
          
          if (h > 0.97) {
            float d = length(f);
            float brightness = smoothstep(0.1, 0.0, d) * (h - 0.97) * 30.0;
            
            // Star color variation
            vec3 starCol = mix(vec3(0.8, 0.9, 1.0), vec3(1.0, 0.9, 0.7), fract(h * 123.456));
            col += brightness * starCol;
          }
        }
        
        // Milky way band
        float band = exp(-8.0 * pow(abs(dir.y - 0.1 * sin(dir.x * 3.0)), 2.0));
        col += band * vec3(0.05, 0.03, 0.08);
        
        return col;
      }
      
      // Accretion disk color based on temperature/doppler
      vec3 diskColor(vec3 p, vec3 vel, float r, float rs) {
        float innerR = u_diskInner * rs;
        float outerR = 12.0 * rs;
        
        if (r < innerR || r > outerR) return vec3(0.0);
        
        // Temperature falls off with radius (T ~ r^-0.75)
        float temp = pow(innerR / r, 0.75);
        
        // Disk height check (thin disk approximation)
        float diskHeight = 0.1 * rs;
        if (abs(p.y) > diskHeight * (1.0 + (r - innerR) / (outerR - innerR))) return vec3(0.0);
        
        // Orbital velocity direction (counter-clockwise when viewed from above)
        vec3 orbitalDir = normalize(vec3(-p.z, 0.0, p.x));
        
        // Doppler shift (blue when approaching, red when receding)
        // v_orbital ‚âà sqrt(GM/r) = sqrt(0.5 * rs / r) in geometric units
        float v_orbital = sqrt(0.5 * rs / r);
        float doppler = dot(normalize(vel), orbitalDir) * v_orbital;
        
        // Gravitational redshift: sqrt(1 - rs/r)
        float gravRedshift = sqrt(max(0.001, 1.0 - rs / r));
        
        // Combined shift
        float shift = gravRedshift * (1.0 - doppler);
        
        // Base color from temperature (blackbody-ish)
        vec3 hotColor = vec3(1.0, 0.9, 0.6);   // Inner hot region
        vec3 coolColor = vec3(0.8, 0.2, 0.05); // Outer cooler region
        vec3 baseColor = mix(coolColor, hotColor, temp);
        
        // Apply doppler coloring
        if (doppler > 0.0) {
          baseColor = mix(baseColor, vec3(0.6, 0.8, 1.0), doppler * 0.5); // Blue shift
        } else {
          baseColor = mix(baseColor, vec3(1.0, 0.3, 0.1), -doppler * 0.5); // Red shift
        }
        
        // Brightness
        float brightness = temp * temp * u_diskBrightness;
        brightness *= smoothstep(outerR, outerR * 0.7, r); // Fade at edge
        brightness *= smoothstep(innerR * 0.9, innerR * 1.1, r); // Fade at inner edge
        brightness *= gravRedshift; // Dimmer near black hole
        
        // Turbulence/structure in disk
        float angle = atan(p.z, p.x);
        float turbulence = 0.7 + 0.3 * sin(angle * 8.0 + u_time * 0.5 + r * 2.0);
        turbulence *= 0.8 + 0.2 * sin(angle * 3.0 - u_time * 0.3);
        
        return baseColor * brightness * turbulence;
      }
      
      // Main ray marching with gravitational lensing
      vec3 trace(vec3 ro, vec3 rd) {
        float rs = schwarzschildRadius(u_mass);
        float rph = photonSphereRadius(u_mass);
        
        vec3 pos = ro;
        vec3 vel = rd;
        
        vec3 diskLight = vec3(0.0);
        
        for (int i = 0; i < MAX_STEPS; i++) {
          float r = length(pos);
          
          // Fell into black hole
          if (r < rs * 1.01) {
            return diskLight * 0.5; // Some disk light may have accumulated
          }
          
          // Escaped to infinity
          if (r > 100.0) {
            return starField(normalize(vel)) + diskLight;
          }
          
          // Gravitational acceleration (Newtonian approximation works visually)
          // a = -GM/r¬≤ * r_hat = -0.5 * rs / r¬≤ * r_hat
          vec3 rHat = pos / r;
          float accel = -0.5 * rs / (r * r);
          
          // Extra bending near photon sphere for visual accuracy
          if (r < rph * 2.0) {
            accel *= 1.0 + 0.5 * pow(rph / r, 2.0);
          }
          
          // Adaptive step size - smaller near black hole
          float step = STEP_SIZE * (0.5 + 0.5 * smoothstep(rs, rs * 5.0, r));
          
          // Update velocity (leapfrog integration)
          vel += rHat * accel * step;
          vel = normalize(vel); // Keep unit velocity (light speed)
          
          // Update position
          pos += vel * step;
          
          // Check disk intersection
          if (u_showDisk && abs(pos.y) < 0.15 * rs) {
            float diskR = length(vec2(pos.x, pos.z));
            vec3 dc = diskColor(pos, vel, diskR, rs);
            diskLight += dc * step * 2.0;
          }
        }
        
        return starField(normalize(vel)) + diskLight;
      }
      
      void main() {
        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;
        
        // Camera setup
        vec3 ro = u_cameraPos;
        vec3 ta = u_cameraTarget;
        mat3 cam = setCamera(ro, ta);
        
        // Ray direction with slight fisheye for drama
        float fov = 1.5;
        vec3 rd = cam * normalize(vec3(uv * fov, 1.0));
        
        // Trace the ray
        vec3 col = trace(ro, rd);
        
        // Tone mapping
        col = col / (1.0 + col);
        
        // Gamma correction
        col = pow(col, vec3(0.4545));
        
        // Vignette
        float vig = 1.0 - 0.3 * dot(uv, uv);
        col *= vig;
        
        fragColor = vec4(col, 1.0);
      }
    `;

    // Compile shader
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Create program
    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    // Fullscreen quad
    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const uniforms = {
      resolution: gl.getUniformLocation(program, 'u_resolution'),
      time: gl.getUniformLocation(program, 'u_time'),
      cameraPos: gl.getUniformLocation(program, 'u_cameraPos'),
      cameraTarget: gl.getUniformLocation(program, 'u_cameraTarget'),
      mass: gl.getUniformLocation(program, 'u_mass'),
      diskBrightness: gl.getUniformLocation(program, 'u_diskBrightness'),
      diskInner: gl.getUniformLocation(program, 'u_diskInner'),
      showDisk: gl.getUniformLocation(program, 'u_showDisk'),
    };

    // Camera state
    let cameraTheta = 0.3;
    let cameraPhi = 0.4;
    let cameraDistance = 25;
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };

    // Parameters
    let mass = 1.5;
    let diskBrightness = 1.0;
    let diskInner = 3.0;
    let showDisk = true;

    // Mouse controls
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouse = { x: e.clientX, y: e.clientY };
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastMouse.x;
      const dy = e.clientY - lastMouse.y;
      cameraTheta -= dx * 0.005;
      cameraPhi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraPhi + dy * 0.005));
      lastMouse = { x: e.clientX, y: e.clientY };
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraDistance *= 1 + e.deltaY * 0.001;
      cameraDistance = Math.max(8, Math.min(100, cameraDistance));
    });

    // Touch controls
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (!isDragging || e.touches.length !== 1) return;
      e.preventDefault();
      const dx = e.touches[0].clientX - lastMouse.x;
      const dy = e.touches[0].clientY - lastMouse.y;
      cameraTheta -= dx * 0.005;
      cameraPhi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraPhi + dy * 0.005));
      lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });

    canvas.addEventListener('touchend', () => isDragging = false);

    // UI controls
    document.getElementById('mass').addEventListener('input', (e) => {
      mass = parseFloat(e.target.value);
      document.getElementById('massVal').textContent = mass.toFixed(1);
    });

    document.getElementById('diskBright').addEventListener('input', (e) => {
      diskBrightness = parseFloat(e.target.value);
      document.getElementById('diskVal').textContent = diskBrightness.toFixed(1);
    });

    document.getElementById('diskInner').addEventListener('input', (e) => {
      diskInner = parseFloat(e.target.value);
      document.getElementById('innerVal').textContent = diskInner.toFixed(1);
    });

    document.getElementById('showDisk').addEventListener('change', (e) => {
      showDisk = e.target.checked;
    });

    // Resize handler
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    // Animation loop
    function render(time) {
      const t = time * 0.001;

      // Calculate camera position
      const camX = cameraDistance * Math.cos(cameraPhi) * Math.sin(cameraTheta);
      const camY = cameraDistance * Math.sin(cameraPhi);
      const camZ = cameraDistance * Math.cos(cameraPhi) * Math.cos(cameraTheta);

      gl.useProgram(program);
      gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
      gl.uniform1f(uniforms.time, t);
      gl.uniform3f(uniforms.cameraPos, camX, camY, camZ);
      gl.uniform3f(uniforms.cameraTarget, 0, 0, 0);
      gl.uniform1f(uniforms.mass, mass);
      gl.uniform1f(uniforms.diskBrightness, diskBrightness);
      gl.uniform1f(uniforms.diskInner, diskInner);
      gl.uniform1i(uniforms.showDisk, showDisk);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
